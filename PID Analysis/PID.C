#include <iostream>
#include <vector>
#include <cmath>
#include "TString.h"
#include "TTree.h"
#include "TFile.h"
#include "TH1D.h"
#include "TF1.h"
#include "TGraph.h"
#include "TGraphErrors.h"
#include "TCanvas.h"
#include "TMultiGraph.h"
#include "TLegend.h"
#include "TPad.h"
#include "TLatex.h"

// ---------------------------------------- Notes ---------------------------------------------
//
//  log-scale for dE/dx was chosen due to how many pion events there were in the data sample.
//  log-scale suppressed the pion-contribution enough so that the kaon and proton statistics showed up.
//  to this effort further, the TH2 graphed in the pid() function has its z-axis log-scaled as well for visual convenience
//  linear-scaling also works, but log-scale produced smoother, more accurate fits, and thus was chosen for this analysis.
//
//  pid() does the actual pid analysis, genHists() outputs a TFile containing all the dE/dx histograms binned by a particular p range
//  TH2Gen() creates and outputs the 2d histogram used in the PID analysis
//
//  i've included helper functions used to help test, debug and see certain values/distributions:
//      • PID_fit() does the actual fitting for each histogram, and extracts mean,sigma values for each histogram
//      • histFit() plots individual histograms (already generated w/ genHists()) with their particular "removeWindow" (see PID_fit)
//        and shows how well the fit is done. I used this to find the p_max values found in PID_fit
//      • plotHists() just plots all the histograms that were generated by the genHists() function. This was mainly just for convenience since
//        dealing with TFiles and plotting the histograms individually can be a pain.
//
//  The PID_fit() function uses a fit_method of finding the maxima of the initial distribution to get good initial guesses for the particle means.
//  This method relies on the parameter removeWindow, where once a maxima is found, everything within a removeWindow distance is removed and the next maxima is found
//  For different p-bins, the removeWindow will be different depending on how close the peaks are to each other. To find good removeWindow values I used the histFit() function.
//  For small p-bins (ex: .3 to .4), the removeWindow can be large, but closer to p~1 the kaon peak starts to merge with the pions so the removeWindow must be lowered.
//  Past a p of about 1.2 GeV, the pion and kaon distributions are indistinguishable, and so the fitting method switches to a 2-gaussian to adjust for this.
//  All 3 particles become indistinguishable past p = 1.8 GeV, and so the fits stop at this point (although i've extended the plot to 2 GeV for visual convenience)
//


// ******************** Main Macros (PID, PID_fit, GenHists, TH2Gen) ********************

std::vector<std::vector<double>> PID_fit(double min, double max, TH1D* hist){
    //helper function for pid() that performs the actual fit
    TH1D* histCopy = (TH1D*) hist->Clone("htmp");
    std::vector<std::pair<double, double>> peaks; // (mean, amplitude pairs)

    //  All these values were individually and manually tested for fit accuracy (see Notes + histTesting function)
    double removeWindow = .5;
    if (min == .6 || min == .7) removeWindow = .3;
    if (min == .8) removeWindow = .2;
    if (min == 1.0 || min == .9) removeWindow = .1;
    if (min == 1.2) removeWindow = .3;
    if (min == 1.5 || min == 1.6 ) removeWindow = .3;
    if (min >= 1.7 && min <= 1.9) removeWindow = .1;

    //3 gaussian fit if min < 1.1 (pion-kaon distinguishability)
    if(min < 1.1) {
    for(int i=0; i < 3; i++) { //loops through and finds 3 maximum bins for initial guesses
        int maxBin = histCopy->GetMaximumBin();
        double mu = histCopy->GetBinCenter(maxBin);
        double A = histCopy->GetBinContent(maxBin);
        peaks.emplace_back(mu, A);
        int bLow = histCopy->GetXaxis()->FindBin(mu - removeWindow);
        int bHigh = histCopy->GetXaxis()->FindBin(mu + removeWindow);
        for(int b=bLow; b <= bHigh; b++){
            histCopy->SetBinContent(b, 0);
        }
    }
    delete histCopy;

    std::sort(peaks.begin(), peaks.end(), //puts into correct order
                [](auto &a, auto &b){ return a.first < b.first; });

    TF1 *fit = new TF1( "fit",
                        "gaus(0) + gaus(3) + gaus(6)",
                        hist->GetXaxis()->GetXmin(),
                        hist->GetXaxis()->GetXmax());

    for(int i=0; i<3; i++) {
        double mu = peaks[i].first;
        double A = peaks[i].second;
        fit->SetParameter(0+3*i, A);
        fit->SetParameter(1+3*i, mu);
        fit->SetParLimits(1+3*i, mu - removeWindow, mu + removeWindow);
        fit->SetParameter(2+3*i, .1);
        fit->SetParLimits(2+3*i, .01, .5);
    }

    hist->Fit(fit, "RQ0");
    double  mean_pion = fit->GetParameter(1), sigma_pion = fit->GetParameter(2),
            mean_kaon = fit->GetParameter(4), sigma_kaon = fit->GetParameter(5),
            mean_proton = fit->GetParameter(7), sigma_proton = fit->GetParameter(8);

    std::vector<std::vector<double>> output = {{mean_pion, sigma_pion}, {mean_kaon, sigma_kaon}, {mean_proton, sigma_proton}};
    return output;}

    //2 gaussian fit after 1.1 due to kaon-pion indistinguishability
        for(int i=0; i < 2; i++) { //loops through and finds 2 maximum bins for initial guesses
        int maxBin = histCopy->GetMaximumBin();
        double mu = histCopy->GetBinCenter(maxBin);
        double A = histCopy->GetBinContent(maxBin);
        peaks.emplace_back(mu, A);
        int bLow = histCopy->GetXaxis()->FindBin(mu - removeWindow);
        int bHigh = histCopy->GetXaxis()->FindBin(mu + removeWindow);
        for(int b=bLow; b <= bHigh; b++){
            histCopy->SetBinContent(b, 0);
        }
    }
    delete histCopy;

    std::sort(peaks.begin(), peaks.end(), //puts into correct order
                [](auto &a, auto &b){ return a.first < b.first; });

    TF1 *fit = new TF1( "fit",
                        "gaus(0) + gaus(3)",
                        hist->GetXaxis()->GetXmin(),
                        hist->GetXaxis()->GetXmax());

    for(int i=0; i<2; i++) {
        double mu = peaks[i].first;
        double A = peaks[i].second;
        fit->SetParameter(0+3*i, A);
        fit->SetParameter(1+3*i, mu);
        fit->SetParLimits(1+3*i, mu - removeWindow, mu + removeWindow);
        fit->SetParameter(2+3*i, .1);
        fit->SetParLimits(2+3*i, .01, .5);
    }

    hist->Fit(fit, "RQ0");
    double  mean_pion = fit->GetParameter(1), sigma_pion = fit->GetParameter(2),
            mean_kaon = fit->GetParameter(1), sigma_kaon = fit->GetParameter(2),
            mean_proton = fit->GetParameter(4), sigma_proton = fit->GetParameter(5);

    std::vector<std::vector<double>> output = {{mean_pion, sigma_pion}, {mean_kaon, sigma_kaon}, {mean_proton, sigma_proton}};
    return output;
}

void pid() {

    // Draws a 2d histogram of log(dE/dx) vs p.
    // Fits pion, kaon, and proton curves w/ bounds to the histogram.
    // Draws everything overlayed on top of each other and exports a Tfile
    // containing every particle fit (mean and upper/lower bounds) and its parameters

    double p_min = .3, p_max = 1.8, delta = .1;
    int n_iter = ceil((p_max - p_min)/delta);
    std::vector<double> x_p, sigma_x, y_pion, y_kaon, y_prot, sigma_pion, sigma_kaon, sigma_prot;
    auto *histf = TFile::Open("TH2.root"); //root file where dE/dx, p 2dhist is located
    TH2D *TH2hist = (TH2D*) histf->Get("hist"); //bkg 2d histogram
    TFile *f = TFile::Open("logscale_histograms.root"); //root file where all p-binned hists are located
    std::vector<TH1D*> hists;
    for(int i = 0; i <= n_iter; i++) {
        double p_lo = p_min + i*delta; double p_hi = p_lo + delta;
        //adheres to naming convention used in hist generation (see "genHists()" function for more)
        auto *hist = (TH1D*)f->Get(Form("hist%.1f_%.1f", p_lo, p_hi));
        hists.push_back(hist);
    }

    // ******************** Collecting mean, sigma data ********************
    for(int i = 0; i < n_iter; i++){
        double min = p_min + i*delta;
        double max = min + delta;
        double mid = (min + max)/2;
        // std::cout << "Processing Iteration Number " << i+1 <<"\n";
        TH1D *hist = hists[i];
        std::vector<std::vector<double>> x = PID_fit(min, max, hist); //PID_fit() does the actual fitting for min-max range
        x_p.push_back(mid);
        sigma_x.push_back(delta/2);

        y_pion.push_back(x[0][0]);
        y_kaon.push_back(x[1][0]);
        y_prot.push_back(x[2][0]);

        sigma_pion.push_back(x[0][1]);
        sigma_kaon.push_back(x[1][1]);
        sigma_prot.push_back(x[2][1]);
    }

    std::vector<double> y_pion_hi, y_pion_lo, y_kaon_hi, y_kaon_lo, y_prot_hi, y_prot_lo;
    for(int i = 0; i < n_iter; i++) {
        y_pion_hi.push_back(y_pion[i] + sigma_pion[i]);
        y_pion_lo.push_back(y_pion[i] - sigma_pion[i]);

        y_kaon_hi.push_back(y_kaon[i] + sigma_kaon[i]);
        y_kaon_lo.push_back(y_kaon[i] - sigma_kaon[i]);

        y_prot_hi.push_back(y_prot[i] + sigma_prot[i]);
        y_prot_lo.push_back(y_prot[i] - sigma_prot[i]);
    }

    // ******************** Fitting ********************

    //  the pion distribution is pretty flat, so the quadratic term in the exponential is dropped
    auto f_pion = new TF1("f_pion", "[0] + exp([1] + [2]*x)", p_min, p_max);
    auto f_kaon = new TF1("f_kaon", "[0] + exp([1] + [2]*x + [3]*x*x)", p_min, p_max);
    auto f_prot = new TF1("f_prot", "[0] + exp([1] + [2]*x + [3]*x*x)", p_min, p_max);

    auto f_pion_hi = new TF1("f_pion_hi", "[0] + exp([1] + [2]*x)", p_min, p_max);
    auto f_kaon_hi = new TF1("f_kaon_hi", "[0] + exp([1] + [2]*x + [3]*x*x)", p_min, p_max);
    auto f_prot_hi = new TF1("f_prot_hi", "[0] + exp([1] + [2]*x + [3]*x*x)", p_min, p_max);

    auto f_pion_lo = new TF1("f_pion_lo", "[0] + exp([1] + [2]*x)", p_min, p_max);
    auto f_kaon_lo = new TF1("f_kaon_lo", "[0] + exp([1] + [2]*x + [3]*x*x)", p_min, p_max);
    auto f_prot_lo = new TF1("f_prot_lo", "[0] + exp([1] + [2]*x + [3]*x*x)", p_min, p_max);

    // initial guesses for parameters (note the 3rd and 4th parameters must be negative)
    const double pars_pion[] = { 0.943044, 1.49651, -14.1073};
    const double pars_kaon[] = { 0.912017, 1.63328, -5.24217, -1.75516 };
    const double pars_prot[] = { 0.89, 1.9, -1, -.5 };

    f_kaon->SetParLimits(3, -10, 0); f_kaon_hi->SetParLimits(3, -10, 0); f_kaon_lo->SetParLimits(3, -10, 0); //3rd par must be negative
    f_kaon->SetParLimits(2, -10, 0);//2nd parameter must also be negative for kaon (this help fixes an overfitting problem encountered)
    f_prot->SetParLimits(3, -5, 0); f_prot_hi->SetParLimits(3, -5, 0); f_prot_lo->SetParLimits(3, -5, 0); //3rd par for prot is also negative

    f_pion->SetParameters(pars_pion); f_kaon->SetParameters(pars_kaon); f_prot->SetParameters(pars_prot);
    f_pion_hi->SetParameters(pars_pion); f_kaon_hi->SetParameters(pars_kaon); f_prot_hi->SetParameters(pars_prot);
    f_pion_lo->SetParameters(pars_pion); f_kaon_lo->SetParameters(pars_kaon); f_prot_lo->SetParameters(pars_prot);

    TGraphErrors *pion = new TGraphErrors(x_p.size(), &x_p[0], &y_pion[0], &sigma_x[0], &sigma_pion[0]);
    TGraphErrors *kaon = new TGraphErrors(x_p.size(), &x_p[0], &y_kaon[0], &sigma_x[0], &sigma_kaon[0]);
    TGraphErrors *prot = new TGraphErrors(x_p.size(), &x_p[0], &y_prot[0], &sigma_x[0], &sigma_prot[0]);

    TGraph *pion_hi = new TGraph(x_p.size(), &x_p[0], &y_pion_hi[0]);
    TGraph *kaon_hi = new TGraph(x_p.size(), &x_p[0], &y_kaon_hi[0]);
    TGraph *prot_hi = new TGraph(x_p.size(), &x_p[0], &y_prot_hi[0]);

    TGraph *pion_lo = new TGraph(x_p.size(), &x_p[0], &y_pion_lo[0]);
    TGraph *kaon_lo = new TGraph(x_p.size(), &x_p[0], &y_kaon_lo[0]);
    TGraph *prot_lo = new TGraph(x_p.size(), &x_p[0], &y_prot_lo[0]);

    //Fits silently and over the range and not plotting immediately
    pion->Fit("f_pion", "RQ0"); kaon->Fit("f_kaon", "RQ0"); prot->Fit("f_prot", "RQ0");
    pion_hi->Fit("f_pion_hi", "RQ0"); kaon_hi->Fit("f_kaon_hi", "RQ0"); prot_hi->Fit("f_prot_hi", "RQ0");
    pion_lo->Fit("f_pion_lo", "RQ0"); kaon_lo->Fit("f_kaon_lo", "RQ0"); prot_lo->Fit("f_prot_lo", "RQ0");

    //Mean
    double A1_pion, A2_pion, A3_pion;
    double A1_kaon, A2_kaon, A3_kaon, A4_kaon;
    double A1_prot, A2_prot, A3_prot, A4_prot;
    A1_pion = f_pion->GetParameter(0); A2_pion = f_pion->GetParameter(1); A3_pion = f_pion->GetParameter(2);
    A1_kaon = f_kaon->GetParameter(0); A2_kaon = f_kaon->GetParameter(1); A3_kaon = f_kaon->GetParameter(2); A4_kaon = f_kaon->GetParameter(3);
    A1_prot = f_prot->GetParameter(0); A2_prot = f_prot->GetParameter(1); A3_prot = f_prot->GetParameter(2); A4_prot = f_prot->GetParameter(3);
    std::cout << "pion" << "{ " << A1_pion << " , " << A2_pion << " , " << A3_pion << "}" << "\n";
    std::cout << "kaon" << "{ " << A1_kaon << " , " << A2_kaon << " , " << A3_kaon << " , " << A4_kaon << "}" << "\n";
    std::cout << "prot" << "{ " << A1_prot << " , " << A2_prot << " , " << A3_prot << " , " << A4_prot << "}" << "\n";

    //Upper Bound (+1sigma)
    double A1_pion_hi, A2_pion_hi, A3_pion_hi;
    double A1_kaon_hi, A2_kaon_hi, A3_kaon_hi, A4_kaon_hi;
    double A1_prot_hi, A2_prot_hi, A3_prot_hi, A4_prot_hi;
    A1_pion_hi = f_pion_hi->GetParameter(0); A2_pion_hi = f_pion_hi->GetParameter(1); A3_pion_hi = f_pion_hi->GetParameter(2);
    A1_kaon_hi = f_kaon_hi->GetParameter(0); A2_kaon_hi = f_kaon_hi->GetParameter(1); A3_kaon_hi = f_kaon_hi->GetParameter(2); A4_kaon_hi = f_kaon_hi->GetParameter(3);
    A1_prot_hi = f_prot_hi->GetParameter(0); A2_prot_hi = f_prot_hi->GetParameter(1); A3_prot_hi = f_prot_hi->GetParameter(2); A4_prot_hi = f_prot_hi->GetParameter(3);
    std::cout << "pion_hi" << "{ " << A1_pion_hi << " , " << A2_pion_hi << " , " << A3_pion_hi << "}" << "\n";
    std::cout << "kaon_hi" << "{ " << A1_kaon_hi << " , " << A2_kaon_hi << " , " << A3_kaon_hi << " , " << A4_kaon_hi << "}" << "\n";
    std::cout << "prot_hi" << "{ " << A1_prot_hi << " , " << A2_prot_hi << " , " << A3_prot_hi << " , " << A4_prot_hi << "}" << "\n";

    //lower bound (-1sigma)
    double A1_pion_lo, A2_pion_lo, A3_pion_lo;
    double A1_kaon_lo, A2_kaon_lo, A3_kaon_lo, A4_kaon_lo;
    double A1_prot_lo, A2_prot_lo, A3_prot_lo, A4_prot_lo;
    A1_pion_lo = f_pion_lo->GetParameter(0); A2_pion_lo = f_pion_lo->GetParameter(1); A3_pion_lo = f_pion_lo->GetParameter(2);
    A1_kaon_lo = f_kaon_lo->GetParameter(0); A2_kaon_lo = f_kaon_lo->GetParameter(1); A3_kaon_lo = f_kaon_lo->GetParameter(2); A4_kaon_lo = f_kaon_lo->GetParameter(3);
    A1_prot_lo = f_prot_lo->GetParameter(0); A2_prot_lo = f_prot_lo->GetParameter(1); A3_prot_lo = f_prot_lo->GetParameter(2); A4_prot_lo = f_prot_lo->GetParameter(3);
    std::cout << "pion_lo" << "{ " << A1_pion_lo << " , " << A2_pion_lo << " , " << A3_pion_lo << "}" << "\n";
    std::cout << "kaon_lo" << "{ " << A1_kaon_lo << " , " << A2_kaon_lo << " , " << A3_kaon_lo << " , " << A4_kaon_lo << "}" << "\n";
    std::cout << "prot_lo" << "{ " << A1_prot_lo << " , " << A2_prot_lo << " , " << A3_prot_lo << " , " << A4_prot_lo << "}" << "\n";

    // ******************** Visuals + Saving into new Functions + Plotting ********************

    int pion_col = 857, kaon_col = 873, prot_col = 897; // blue, purple, red respectively

    //  mean
    auto fit_pion = new TF1("fdedxPionCenter", "[0] + exp([1] + [2]*x)", .3, p_max);
    auto fit_kaon = new TF1("fdedxKaonCenter", "[0] + exp([1] + [2]*x + [3]*x*x)", .3, p_max);
    auto fit_prot = new TF1("fdedxProtCenter", "[0] + exp([1] + [2]*x + [3]*x*x)", .3, p_max);
    fit_pion->SetParameter(0, A1_pion); fit_pion->SetParameter(1, A2_pion); fit_pion->SetParameter(2, A3_pion);
    fit_kaon->SetParameter(0, A1_kaon); fit_kaon->SetParameter(1, A2_kaon); fit_kaon->SetParameter(2, A3_kaon); fit_kaon->SetParameter(3, A4_kaon);
    fit_prot->SetParameter(0, A1_prot); fit_prot->SetParameter(1, A2_prot); fit_prot->SetParameter(2, A3_prot); fit_prot->SetParameter(3, A4_prot);

    fit_pion->SetLineColor(pion_col); fit_pion->SetLineWidth(3);
    fit_kaon->SetLineColor(kaon_col); fit_kaon->SetLineWidth(3);
    fit_prot->SetLineColor(prot_col); fit_prot->SetLineWidth(3);

    //  upper bound (+1sigma)
    auto fit_pion_hi = new TF1("fdedxPionSigmaHi", "[0] + exp([1] + [2]*x)", .3, p_max);
    auto fit_kaon_hi = new TF1("fdedxKaonSigmaHi", "[0] + exp([1] + [2]*x + [3]*x*x)", .3, p_max);
    auto fit_prot_hi = new TF1("fdedxProtSigmaHi", "[0] + exp([1] + [2]*x + [3]*x*x)", .3, p_max);
    fit_pion_hi->SetParameter(0, A1_pion_hi); fit_pion_hi->SetParameter(1, A2_pion_hi); fit_pion_hi->SetParameter(2, A3_pion_hi);
    fit_kaon_hi->SetParameter(0, A1_kaon_hi); fit_kaon_hi->SetParameter(1, A2_kaon_hi); fit_kaon_hi->SetParameter(2, A3_kaon_hi); fit_kaon_hi->SetParameter(3, A4_kaon_hi);
    fit_prot_hi->SetParameter(0, A1_prot_hi); fit_prot_hi->SetParameter(1, A2_prot_hi); fit_prot_hi->SetParameter(2, A3_prot_hi); fit_prot_hi->SetParameter(3, A4_prot_hi);

    fit_pion_hi->SetLineColor(pion_col); fit_pion_hi->SetLineWidth(3); fit_pion_hi->SetLineStyle(9);
    fit_kaon_hi->SetLineColor(kaon_col); fit_kaon_hi->SetLineWidth(3); fit_kaon_hi->SetLineStyle(9);
    fit_prot_hi->SetLineColor(prot_col); fit_prot_hi->SetLineWidth(3); fit_prot_hi->SetLineStyle(9);

    //  lower bound (-1sigma)
    auto fit_pion_lo = new TF1("fdedxPionSigmaLo", "[0] + exp([1] + [2]*x)", .3, p_max);
    auto fit_kaon_lo = new TF1("fdedxKaonSigmaLo", "[0] + exp([1] + [2]*x + [3]*x*x)", .3, p_max);
    auto fit_prot_lo = new TF1("fdedxProtSigmaLo", "[0] + exp([1] + [2]*x + [3]*x*x)", .3, p_max);
    fit_pion_lo->SetParameter(0, A1_pion_lo); fit_pion_lo->SetParameter(1, A2_pion_lo); fit_pion_lo->SetParameter(2, A3_pion_lo);
    fit_kaon_lo->SetParameter(0, A1_kaon_lo); fit_kaon_lo->SetParameter(1, A2_kaon_lo); fit_kaon_lo->SetParameter(2, A3_kaon_lo); fit_kaon_lo->SetParameter(3, A4_kaon_lo);
    fit_prot_lo->SetParameter(0, A1_prot_lo); fit_prot_lo->SetParameter(1, A2_prot_lo); fit_prot_lo->SetParameter(2, A3_prot_lo); fit_prot_lo->SetParameter(3, A4_prot_lo);

    fit_pion_lo->SetLineColor(pion_col); fit_pion_lo->SetLineWidth(3); fit_pion_lo->SetLineStyle(9);
    fit_kaon_lo->SetLineColor(kaon_col); fit_kaon_lo->SetLineWidth(3); fit_kaon_lo->SetLineStyle(9);
    fit_prot_lo->SetLineColor(prot_col); fit_prot_lo->SetLineWidth(3); fit_prot_lo->SetLineStyle(9);

    //  Canvas + Output Plots

    // Actual PID plot
    TCanvas *c = new TCanvas("c","PID",800,800);
    gPad->SetRightMargin(0.15);
    gPad->SetLogz();
    gStyle->SetPalette(kGreyScale);
    TH2hist->Draw("COLZ");

    pion->Draw("same");
    kaon->Draw("same");
    prot->Draw("same");

    fit_pion->Draw("L same");
    fit_kaon->Draw("L same");
    fit_prot->Draw("L same");

    fit_pion_hi->Draw("L same");
    fit_kaon_hi->Draw("L same");
    fit_prot_hi->Draw("L same");

    fit_pion_lo->Draw("L same");
    fit_kaon_lo->Draw("L same");
    fit_prot_lo->Draw("L same");

    auto *mg = new TMultiGraph();
    pion->SetMarkerColor(pion_col); kaon->SetMarkerColor(kaon_col); prot->SetMarkerColor(prot_col);
    mg->Add(pion); mg->Add(kaon); mg->Add(prot);

    TLegend *leg = new TLegend(0.65, 0.65, 0.90, 0.90);
    leg->SetTextFont(42); leg->SetTextSize(0.04);
    leg->SetBorderSize(0); leg->SetFillStyle(0);
    leg->AddEntry(fit_pion,"pion","L");
    leg->AddEntry(fit_kaon,"kaon","L");
    leg->AddEntry(fit_prot,"proton","L");

    leg->Draw();
    c->Update();
    
    // No TGraph Data plot
    TCanvas *cfuncs = new TCanvas("cfunc","PID functions",800,800);
    gPad->SetRightMargin(0.15);
    gPad->SetLogz();
    gStyle->SetPalette(kGreyScale);
    TH2hist->Draw("COLZ");

    fit_pion->Draw("L same");
    fit_kaon->Draw("L same");
    fit_prot->Draw("L same");

    fit_pion_hi->Draw("L same");
    fit_kaon_hi->Draw("L same");
    fit_prot_hi->Draw("L same");

    fit_pion_lo->Draw("L same");
    fit_kaon_lo->Draw("L same");
    fit_prot_lo->Draw("L same");
    
    TLegend *leg1 = new TLegend(0.65, 0.65, 0.90, 0.90);
    leg1->SetTextFont(42); leg1->SetTextSize(0.04);
    leg1->SetBorderSize(0); leg1->SetFillStyle(0);
    leg1->AddEntry(fit_pion,"pion","L");
    leg1->AddEntry(fit_kaon,"kaon","L");
    leg1->AddEntry(fit_prot,"proton","L");

    cfuncs->Update();


    //Exporting the fitting functions into a TFile
    TFile *fexport = new TFile("pidfuncs.root", "RECREATE");
    fexport->cd();

    f_pion->Write();
    f_pion_hi->Write();
    f_pion_lo->Write();

    f_kaon->Write();
    f_kaon_hi->Write();
    f_kaon_lo->Write();

    f_prot->Write();
    f_prot_hi->Write();
    f_prot_lo->Write();

    fexport->Close();
    delete fexport;
}

void genHists(const double p_lo = .3, const double p_hi = 2.0, const double p_delta = .1, const int Nbins = 100) {
    //  Generates all the histograms within a p_delta range from p_lo to p_hi
    //  Gets the long computation out of the way so that fitting and pid() runs fast

    std::vector<TH1D*> hists;
    std::vector<TCanvas*> cs;
    double x_min, x_max;
    x_min = 0; //1.5 for linear scale
    x_max = 3;
    const int num_iter = 1 + (p_hi - p_lo)/p_delta;
    for(int i = 0; i < num_iter; i++) {
        double p_min = p_lo + i*p_delta; double p_max = p_min + p_delta;

        // If dealing with linear scale:
        // if(p_min == .3) x_max = 15;
        // if(p_min == .4) x_max = 12;
        // if(p_min == .5) x_max = 10;
        // if(p_min == .6) x_max = 8.5;
        // if(p_min == .7) x_max = 7.5;
        // if(p_min == .8) x_max = 6;
        // if(p_min == .9) x_max = 6;
        // if(p_min == 1) x_max = 5;
        // if(p_min >= 1.1 && p_min != 1.4) x_max = 4.5;
        // if(p_min == 1.4) x_max = 4;

        TH1D *hist = new TH1D(Form("hist%.1f_%.1f", p_min, p_max), Form("dE/dx %.1f - %.1f", p_min, p_max), Nbins, x_min, x_max);
        hist->GetXaxis()->SetTitle("log(dE/dx) (MeV/cm)");
        hist->GetYaxis()->SetTitle("Entries");
        hist->Sumw2();
        hists.push_back(hist);
    }

    TFile *fInput = new TFile("20250528_Skim_2023Data_Feb2025ReReco_NEW_HIForward01235679.root");
    TTree *tree = (TTree*)fInput->Get("Tree");
    long int nentries = tree->GetEntries();

    int Dsize; //how many D-meson candidates there are
    std::vector<double> *Dtrk1Pt = nullptr;
    std::vector<double> *Dtrk1Eta = nullptr; //pseudorapidity
    std::vector<double> *Dtrk1dedx = nullptr;
    tree->SetBranchAddress("Dsize", &Dsize);
    tree->SetBranchAddress("Dtrk1Eta", &Dtrk1Eta);
    tree->SetBranchAddress("Dtrk1Pt", &Dtrk1Pt);
    tree->SetBranchAddress("Dtrk1dedx", &Dtrk1dedx);

    for (long int jentry=0; jentry<nentries;jentry++) {
    tree->GetEntry(jentry);
    // if (jentry%1'000'000==0) std::cout << "Processing entry " << jentry << std::endl;
    for (int i=0; i<Dsize; i++) {
        double p = (Dtrk1Pt->at(i)) * cosh(Dtrk1Eta->at(i)); //change p_value name
        for(int k = 0; k < num_iter; k++){
            double p_min = p_lo + k*p_delta; double p_max = p_min + p_delta;
            if (p < p_min || p > p_max) continue;
            hists[k]->Fill(log(Dtrk1dedx->at(i)));
        }}}

    TFile *f = new TFile("logscale_histograms.root", "RECREATE");
    for(int i = 0; i < num_iter; i++) {
        f->cd();
        hists[i]->Write();
    }
    f->Close();
    delete f;

    for(int i = 0; i < num_iter; i++){
        double p_min = p_lo + i*p_delta; double p_max = p_min + p_delta;
        TCanvas *c = new TCanvas(Form("c%.1f_%.1f", p_min, p_max), Form("c%.1f-%.1f", p_min, p_max));
        hists[i]->Draw();
        cs.push_back(c);
    }
}

void TH2Gen(double xmin = .3, double xmax = 2, double ymin = .5, double ymax = 3){
    //  Generates the dE/dx vs p 2D histogram (outputs a TFile containing the TH2)
    TFile *fInput = new TFile("20250528_Skim_2023Data_Feb2025ReReco_NEW_HIForward01235679.root");
    TTree *tree = (TTree*)fInput->Get("Tree");

    long int nentries = tree->GetEntries();
    int Dsize; //how many D-meson candidates there are
    std::vector<double> *Dtrk1Pt = nullptr;
    std::vector<double> *Dtrk1Eta = nullptr; //pseudorapidity
    std::vector<double> *Dtrk1dedx = nullptr;

    tree->SetBranchAddress("Dsize", &Dsize);
    tree->SetBranchAddress("Dtrk1Eta", &Dtrk1Eta);
    tree->SetBranchAddress("Dtrk1Pt", &Dtrk1Pt);
    tree->SetBranchAddress("Dtrk1dedx", &Dtrk1dedx);

    int xbins = 100; int ybins = 100;

    TH2D *hist = new TH2D("hist", "log(dE/dx) vs p", xbins, xmin, xmax, ybins, ymin, ymax);
    hist->GetXaxis()->SetTitle("p (GeV)");
    hist->GetYaxis()->SetTitle("log(dE/dx) (MeV/cm)");
    hist->SetStats(0);

    for (long int jentry = 0; jentry < nentries; jentry++) {
        tree->GetEntry(jentry);
        // if (jentry%1'000'000==0) std::cout << "Processing entry " << jentry << std::endl;
        for (int i=0; i < Dsize; i++) {
            double pT = Dtrk1Pt->at(i);
            double eta = Dtrk1Eta->at(i);
            double dedx = Dtrk1dedx->at(i);
            double p = pT * std::cosh(eta);

            hist->Fill(p, log(dedx));
        }
    }

    TCanvas *c = new TCanvas("dedx_p_2dhist", "log(dE/dx) vs p", 1000, 1000);
    c->SetLogz();
    hist->Draw();

    TFile *f = new TFile("TH2.root", "RECREATE");
    f->cd();
    hist->Write();
    f->Close();
    delete f;

}

// ******************** Debugging/Helper functions ********************

void plot(double p_min, double p_delta = .1){
    //plots one of the histograms corresponding to a certain p_min to p_max range
    auto *f = TFile::Open("logscale_histograms.root");
    double p_max = p_min + p_delta;

    TH1D *hist = (TH1D*) f->Get(Form("hist%.1f_%.1f", p_min, p_max));

    TCanvas *c = new TCanvas(Form("c%.1f", p_min * 10), Form("%.1f < p < %.1f", p_min, p_max));
    hist->Draw();
}

void histFit(double p_min = .3, double removeWindow = .3) {
    //  Does a fit for a particular input histogram (to test removeWindow values)
    //  Was helpful when trying to get better fits
    double p_max = p_min + .1;

    TFile *f = TFile::Open("logscale_histograms.root");
    // TFile *f = TFile::Open("linearscale_histograms.root");
    TH1D *hist = (TH1D*)f->Get(Form("hist%.1f_%.1f", p_min, p_max));

    TCanvas *dEdxDist = new TCanvas("dEdxDist", "dEdxDist", 1000, 500);
    hist->Draw(); TLatex latex; latex.SetNDC(); latex.SetTextSize(0.04);
    latex.DrawLatex(0.65, 0.85, Form("%.2f < p < %.2f",p_min, p_max));

    if(p_min < 1.1){
    TH1F* dedxCopy = (TH1F*) hist->Clone("htmp");
    std::vector<std::pair<double, double>> peaks; // (mean, amplitude pairs)

    for(int i=0; i < 3; i++) { //loops through and finds 3 maximum bins for initial guesses
        int maxBin = dedxCopy->GetMaximumBin();
        double mu = dedxCopy->GetBinCenter(maxBin);
        double A = dedxCopy->GetBinContent(maxBin);
        peaks.emplace_back(mu, A);
        int bLow = dedxCopy->GetXaxis()->FindBin(mu - removeWindow);
        int bHigh = dedxCopy->GetXaxis()->FindBin(mu + removeWindow);
        for(int b=bLow; b <= bHigh; b++){
            dedxCopy->SetBinContent(b, 0);
        }
    }
    delete dedxCopy;

    std::sort(peaks.begin(), peaks.end(), //puts into correct order
                [](auto &a, auto &b){ return a.first < b.first; });

    TF1 *fit = new TF1( "fit",
                        "gaus(0) + gaus(3) + gaus(6)",
                        hist->GetXaxis()->GetXmin(),
                        hist->GetXaxis()->GetXmax());

    for(int i=0; i<3; i++) {
        double mu = peaks[i].first;
        double A = peaks[i].second;
        fit->SetParameter(0+3*i, A);
        fit->SetParameter(1+3*i, mu);
        fit->SetParLimits(1+3*i, mu - removeWindow, mu + removeWindow);
        fit->SetParameter(2+3*i, .1);
        fit->SetParLimits(2+3*i, .01, .5);
    }

    hist->Fit(fit, "RQ");
    double  mean_pion = fit->GetParameter(1), sigma_pion = fit->GetParameter(2),
            mean_kaon = fit->GetParameter(4), sigma_kaon = fit->GetParameter(5),
            mean_proton = fit->GetParameter(7), sigma_proton = fit->GetParameter(8);

    std::cout   << "\n *********Results********* \n"
                << "Pion:   mu = " << mean_pion << "    sigma = " << sigma_pion << "\n"
                << "Kaon:   mu = " << mean_kaon << "    sigma = " << sigma_kaon << "\n"
                << "Proton: mu = " << mean_proton << "    sigma = " << sigma_proton << "\n";

    fit->SetLineColor(kBlack);
    fit->Draw("SAME");}
    //2-fit (pion-kaon indistinguishability)
    else{
    TH1F* dedxCopy = (TH1F*) hist->Clone("htmp");
    std::vector<std::pair<double, double>> peaks; // (mean, amplitude pairs)

    for(int i=0; i < 2; i++) { //loops through and finds 2 maximum bins for initial guesses
        int maxBin = dedxCopy->GetMaximumBin();
        double mu = dedxCopy->GetBinCenter(maxBin);
        double A = dedxCopy->GetBinContent(maxBin);
        peaks.emplace_back(mu, A);
        int bLow = dedxCopy->GetXaxis()->FindBin(mu - removeWindow);
        int bHigh = dedxCopy->GetXaxis()->FindBin(mu + removeWindow);
        for(int b=bLow; b <= bHigh; b++){
            dedxCopy->SetBinContent(b, 0);
        }
    }
    delete dedxCopy;

    std::sort(peaks.begin(), peaks.end(), //puts into correct order
                [](auto &a, auto &b){ return a.first < b.first; });

    TF1 *fit = new TF1( "fit",
                        "gaus(0) + gaus(3)",
                        hist->GetXaxis()->GetXmin(),
                        hist->GetXaxis()->GetXmax());

    for(int i=0; i<2; i++) {
        double mu = peaks[i].first;
        double A = peaks[i].second;
        fit->SetParameter(0+3*i, A);
        fit->SetParameter(1+3*i, mu);
        fit->SetParLimits(1+3*i, mu - removeWindow, mu + removeWindow);
        fit->SetParameter(2+3*i, .1);
        fit->SetParLimits(2+3*i, .01, .5);
    }

    hist->Fit(fit, "RQ");
    double  mean_pion = fit->GetParameter(1), sigma_pion = fit->GetParameter(2),
            mean_kaon = fit->GetParameter(1), sigma_kaon = fit->GetParameter(2),
            mean_proton = fit->GetParameter(4), sigma_proton = fit->GetParameter(5);

    std::cout   << "\n *********Results********* \n"
                << "Pion:   mu = " << mean_pion << "    sigma = " << sigma_pion << "\n"
                << "Kaon:   mu = " << mean_kaon << "    sigma = " << sigma_kaon << "\n"
                << "Proton: mu = " << mean_proton << "    sigma = " << sigma_proton << "\n";

    fit->SetLineColor(kBlack);
    fit->Draw("SAME");}



}
